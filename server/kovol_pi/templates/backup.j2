#!/usr/bin/python3

import subprocess
import logging
import logging.handlers
import os.path
import datetime


def backup(destination,
           source='/',
           _filter=os.path.expanduser('~/code/backup/backup_filter.txt')):
    global errors
    # Cleanup old backups
    subprocess.run(['duplicity', 'remove-older-than', '3M', destination])
    # Run backup
    backup = subprocess.run([
        'duplicity',
        '--no-encryption',
        '--include-filelist',
        '--allow_source_mismatch',
        _filter,
        '--full-if-older-than',
        '2M',
        source,
        destination])

    # Logging
    if backup.returncode != 0:
        logger.error('Backup to {b} is reporting errors:\n{errors}'.format(
            b=destination, errors=backup.stderr))
        errors = True
    else:
        if backup.stdout:
            logger.info('Backup to {b} info:\n {info}'.format(
                b=destination, info=backup.stdout))


if __name__ == '__main__':
    # Initiate logging
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)
    fh = logging.handlers.RotatingFileHandler(
        os.path.expanduser('~/server_logs/backup.log'))
    f = logging.Formatter('%(asctime)s %(levelname)-8s %(message)s')
    fh.setFormatter(f)
    logger.addHandler(fh)

    # Start program
    logger.info('Backup started')
    errors = False
    print('Starting local backup')
    backup('file://{{ nas_backup_mount_point }}')

    print('Starting remote backup')
    backup('{{ remote_backup_location }}')

    # Log any errors
    if errors:
        logger.error('Backup script finished with errors')
    else:
        logger.info('Backup script finished sucessfully: {d}'.format(
            d=datetime.date.today().strftime('%a %d %b')))
